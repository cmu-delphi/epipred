% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/step_adjust_latency.R
\name{step_adjust_latency}
\alias{step_adjust_latency}
\title{adapt the pipeline to latency in the data}
\usage{
step_adjust_latency(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  method = c("extend_ahead", "locf", "extend_lags"),
  default = NA,
  skip = FALSE,
  prefix = NULL,
  columns = NULL,
  id = recipes::rand_id("epi_lag")
)
}
\arguments{
\item{recipe}{A recipe object. The step will be added to the
sequence of operations for this recipe.}

\item{...}{One or more selector functions to choose variables for this step.
See \code{\link[recipes:selections]{recipes::selections()}} for more details. Typically you will not need
to set this manually, as the necessary adjustments will be done for the
predictors and outcome.}

\item{method}{a character. Determines the method by which the
forecast handles latency. All of these assume the forecast date is the
\code{as_of} of the \code{epi_df}. The options are:
\itemize{
\item \code{"extend_ahead"}: Lengthen the ahead so that forecasting from the last
observation results in a forecast \code{ahead} after the \code{as_of} date. E.g. if
there are 3 days of latency between the last observation and the \code{as_of}
date for a 4 day ahead forecast, the ahead used in practice is actually 7.
\item \code{"locf"}: carries forward the last observed value(s) up to the forecast
date. See the Vignette TODO for equivalents using other steps and more
sophisticated methods of extrapolation.
\item \code{"extend_lags"}: per \code{epi_key} and \code{predictor}, adjusts the lag so that
the shortest lag at predict time is at the last observation. E.g. if the
lags are \code{c(0,7,14)} for data that is 3 days latent, the actual lags used
become \code{c(3,10,17)}
}}

\item{default}{Determines what fills empty rows
left by leading/lagging (defaults to NA).}

\item{skip}{A logical. Should the step be skipped when the
recipe is baked by \code{\link[=bake]{bake()}}? While all operations are baked
when \code{\link[=prep]{prep()}} is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using \code{skip = TRUE} as it may affect
the computations for subsequent operations.}

\item{prefix}{a character. The prefix matching the one used in either
\code{step_epi_ahead} if \code{method="extend_ahead"} or \code{step_epi_lag}
if \code{method="extend_lags"} or "locf".}

\item{id}{A unique identifier for the step}
}
\value{
An updated version of \code{recipe} with the new step added to the
sequence of any existing operations.
}
\description{
In the standard case, the pipeline assumes that the last observation is also
the day from which the forecast is being made. \code{step_adjust_latency} uses the
\code{as_of} date of the \code{epi_df} as the \code{forecast_date}. This is most useful in
realtime and pseudo-prospective forecasting for data where there is some
delay between the day recorded and when that data is available.
}
\details{
The step assumes that the pipeline has already applied either
\code{step_epi_ahead} or \code{step_epi_lag} depending on the value of
\code{"method"}, and that \code{step_epi_naomit} has NOT been run.

The \code{prefix} and \code{id} arguments are unchangeable to ensure that the code runs
properly and to avoid inconsistency with naming. For \code{step_epi_ahead}, they
are always set to \code{"ahead_"} and \code{"epi_ahead"} respectively, while for
\code{step_epi_lag}, they are set to \code{"lag_"} and \verb{"epi_lag}, respectively.
}
\examples{
r <- epi_recipe(case_death_rate_subset) \%>\%
  step_epi_ahead(death_rate, ahead = 7) \%>\%
  #   step_adjust_latency(method = "extend_ahead") \%>\%
  step_epi_lag(death_rate, lag = c(0, 7, 14))
r
}
\seealso{
Other row operation steps: 
\code{\link{step_epi_lag}()},
\code{\link{step_growth_rate}()},
\code{\link{step_lag_difference}()}
}
\concept{row operation steps}
