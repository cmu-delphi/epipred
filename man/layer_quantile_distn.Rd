% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layer_quantile_distn.R
\name{layer_quantile_distn}
\alias{layer_quantile_distn}
\title{Returns predictive quantiles}
\usage{
layer_quantile_distn(
  frosting,
  ...,
  quantile_levels = c(0.25, 0.75),
  truncate = c(-Inf, Inf),
  name = ".pred_distn",
  id = rand_id("quantile_distn")
)
}
\arguments{
\item{frosting}{a \code{frosting} postprocessor}

\item{...}{Unused, include for consistency with other layers.}

\item{quantile_levels}{a vector of probabilities to extract}

\item{truncate}{Do we truncate the distribution to an interval}

\item{name}{character. The name for the output column.}

\item{id}{a random id string}
}
\value{
an updated \code{frosting} postprocessor. An additional column of predictive
quantiles will be added to the predictions.
}
\description{
This function calculates quantiles when the prediction was \emph{distributional}.
Currently, the only distributional engine is \code{quantile_reg()}.
If this engine is used, then this layer will grab out estimated (or extrapolated)
quantiles at the requested quantile values.
}
\examples{
library(dplyr)
jhu <- case_death_rate_subset \%>\%
  filter(time_value > "2021-11-01", geo_value \%in\% c("ak", "ca", "ny"))

r <- recipe(jhu) \%>\%
  step_epi_lag(death_rate, lag = c(0, 7, 14)) \%>\%
  step_epi_ahead(death_rate, ahead = 7) \%>\%
  step_epi_naomit()

wf <- epi_workflow(r, quantile_reg(quantile_levels = c(.25, .5, .75))) \%>\%
  fit(jhu)

f <- frosting() \%>\%
  layer_predict() \%>\%
  layer_quantile_distn() \%>\%
  layer_naomit(.pred)
wf1 <- wf \%>\% add_frosting(f)

p <- forecast(wf1)
p
}
