% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layer_population_scaling.R
\name{layer_population_scaling}
\alias{layer_population_scaling}
\title{Convert per-capita predictions to raw scale}
\usage{
layer_population_scaling(
  frosting,
  ...,
  df,
  by = NULL,
  df_pop_col,
  rate_rescaling = 1,
  create_new = TRUE,
  suffix = "_scaled",
  id = rand_id("population_scaling")
)
}
\arguments{
\item{frosting}{a \code{frosting} postprocessor. The layer will be added to the
sequence of operations for this frosting.}

\item{...}{One or more selector functions to scale variables
for this step. See \code{\link[recipes:selections]{recipes::selections()}} for more details.}

\item{df}{a data frame that contains the population data to be used for
inverting the existing scaling.}

\item{by}{A (possibly named) character vector of variables to join by.

If \code{NULL}, the default, the function will perform a natural join, using all
variables in common across the \code{epi_df} produced by the \code{predict()} call
and the user-provided dataset.
If columns in that \code{epi_df} and \code{df} have the same name (and aren't
included in \code{by}), \code{.df} is added to the one from the user-provided data
to disambiguate.

To join by different variables on the \code{epi_df} and \code{df}, use a named vector.
For example, \code{by = c("geo_value" = "states")} will match \code{epi_df$geo_value}
to \code{df$states}. To join by multiple variables, use a vector with length > 1.
For example, \code{by = c("geo_value" = "states", "county" = "county")} will match
\code{epi_df$geo_value} to \code{df$states} and \code{epi_df$county} to \code{df$county}.

See \code{\link[dplyr:mutate-joins]{dplyr::left_join()}} for more details.}

\item{df_pop_col}{the name of the column in the data frame \code{df} that
contains the population data and used for scaling.}

\item{rate_rescaling}{Sometimes rates are "per 100K" or "per 1M" rather than
"per person". Adjustments can be made here. For example, if the original
rate is "per 100K", then set \code{rate_rescaling = 1e5} to get counts back.}

\item{create_new}{TRUE to create a new column and keep the original column
in the \code{epi_df}.}

\item{suffix}{a character. The suffix added to the column name if
\code{create_new = TRUE}. Default to "_scaled".}

\item{id}{a random id string}
}
\value{
an updated \code{frosting} postprocessor
}
\description{
\code{layer_population_scaling} creates a specification of a frosting layer
that will "undo" per-capita scaling. Typical usage would
load a dataset that contains state-level population, and use it to convert
predictions made from a rate-scale model to raw scale by multiplying by
the population.
Although, it is worth noting that there is nothing special about "population".
The function can be used to scale by any variable. Population is the
standard use case in the epidemiology forecasting scenario. Any value
passed will \emph{multiply} the selected variables while the \code{rate_rescaling}
argument is a common \emph{divisor} of the selected variables.
}
\examples{
library(dplyr)
jhu <- cases_deaths_subset \%>\%
  filter(time_value > "2021-11-01", geo_value \%in\% c("ca", "ny")) \%>\%
  select(geo_value, time_value, cases)

pop_data <- data.frame(states = c("ca", "ny"), value = c(20000, 30000))

r <- epi_recipe(jhu) \%>\%
  step_population_scaling(
    df = pop_data,
    df_pop_col = "value",
    by = c("geo_value" = "states"),
    cases, suffix = "_scaled"
  ) \%>\%
  step_epi_lag(cases_scaled, lag = c(0, 7, 14)) \%>\%
  step_epi_ahead(cases_scaled, ahead = 7, role = "outcome") \%>\%
  step_epi_naomit()

f <- frosting() \%>\%
  layer_predict() \%>\%
  layer_threshold(.pred) \%>\%
  layer_naomit(.pred) \%>\%
  layer_population_scaling(.pred,
    df = pop_data,
    by = c("geo_value" = "states"),
    df_pop_col = "value"
  )

wf <- epi_workflow(r, linear_reg()) \%>\%
  fit(jhu) \%>\%
  add_frosting(f)

forecast(wf)
}
